成员变量是需要内存来存储的，因此，当创建Person对象时，必须要有对应的内存来存储Person对象的成员变量
Person*类型的变量本质就是一个指针变量，也就是说，person变量仅保存了Person对象在内存中的首地址。
形象的说，可以认为Person*类型的变量指向实际的对象。
从本质上，类也是一种指针的变量，因此，程序中定义的Person*类型只是一个存放地址的值，它在被保存在该main（）函数的动态存储区，指向实际的Person对象，而真正的Person对象则存放在堆（heap）内存中。
当一个对象被创建成功后，这个对象将保存在堆内存中，oc不允许直接访问堆内存中的对象，只能通过该对象的指针变量来访问该对象。
person指针变量只存储了一个地址，并为包含任何实际的数据，但他指向实际的Person对象，当调用person指针变量的成员和方法时，实际上是访问person所指向对象的成员变量和方法
堆内存中的对象可以有多个指针，即多个指针变量指向同一个对象，代码如下：
//将person变量的值赋给p2变量
Person*p2 = person；
将person变量的值赋给p2变量，也就是将person变量保存的地址赋给p2变量，这样，p2变量和person变量将指向堆内存中的同一个Person对象。
不管是访问p2变量的成员变量和方法，还是访问person变量和方法，实际上是访问同一个Person对象的成员变量和方法，将会返回相同的访问结果
如果堆内存中的对象没有任何变量指向该对象，那么程序将无法再访问该对象，oc要求用户释放该对象所占用的内存，否则就会造成内存泄漏

//存在的疑问：怎么释放该内存//

内存泄漏：
当程序需要创建对象时，总会为该对象分配内存单元，并用该内存单元来保存该对象。当程序不在需要使用这些对象时，就应该把这些对象所占内存单元收回来，方便以后使用。
如果程序不在需要使用这些对象，就应该把这些对象所占的内存单元收回来，方便以后使用，如果不收回，oc会以为这些内存地址任然被占用着，以后将不会分配这些内存，长此以往，程序可用内存会越来越傻，程序性自然越来越差
oc没有提供自动的垃圾回收机制，因此程序员需要收到回收这些内存，Xcode4.2引入自动引用计数（Automatic Reference Counting，ARC）这个新特性很好的解决了垃圾自动回收的问题

