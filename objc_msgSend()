在oc中，消息时直到运行时才和方法实现绑定的。编译器会把一个消息表达式“[receiver message]"转换成一个对消息函数objc_msgSend()的调用。
该函数有两个主要参数：消息接收者和消息对应的方法名字（也就是方法选标）：
objc_msgSend(receiver,selector)
同时该方法还可以接受消息中任意数目的参数：
objc_msgSend(receiver,selector，arg1，arg2……)
该消息函数做了动态绑定所需要的一切：
首先，找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。
然后，将消息接收者对象（指向消息接收者对象的指针）以及在方法中指定的参数传给找到的方法实现。
最后，将方法实现的返回值作为该函数的返回值返回。
注意：编译器将自动插入调用该消息函数的代码。无须在代码中显示调用该消息函数。
消息机制的关键在于编译器为类和对象生成的机构。每个类的结构中至少包括两个基本元素：
指向父类的指针。
类的方法标。
方法标将方法选标和该类的方法实现的地址关联起来，例如，setOrigin：的方法选标和setOrigin：的方法实现的地址关联。
当新的对象被创建时，其内存同时被分配，实例变量也同时被初始化。对象的第一个实例变量是一个指向该对象的类结构的指针，叫做isa。
通过该指针，对象可以访问它对应的类以及相应的父类。
尽管严格来说这并不是oc语言的一部分，但是oc运行时系统中的对象需要有isa指针。
对象的结构体struct objc_object(objc/objc.h中定义)必须“一致”。
然而，很少需要创建自己的根对象，因为从NSObject和NSProxy继承的对象都自动包括isa变量。
当对象收到消息时，消息函数首先根据该对象的isa指针找到该对象所对应的类的方法表，并从表中寻找该消息对应的方法选标。
如果找不到，objc_msgSend将继续从父类中寻找，直到完成在NSObject类中的寻找。
一旦找到了方法选标，objc_msgSend则以消息接收者对象为参数调用该选标对应的方法实现。
为了加快消息的处理过程，运行时系统通常会将使用过的方法选标和方法实现的地址放入缓存中。
每个类都有一个独立的缓存，同时还包括继承的方法和在该类中定义的方法。消息函数会首先检查消息接收者对象对应的类的缓存（理论上，如果一个方法被使用过一次，那么它很可能被再次使用）
如果在缓存中已经有了需要的方法选标，则消息仅比函数调用慢一点点。
如果程序运行了足够长的时间，那么几乎每个消息都能在缓存中找到方法实现。
在程序运行时，缓存也将随新的消息增加而增加。
