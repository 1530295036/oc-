对象（object）是类的实例，面向对象程序就是围绕着对象建立起来的。
对象具有状态，一个对象用数据值来表示状态。
对象可以操作，用于改变对象的状态。
这些操作被称为对象的方法，方法所影响的数据就是对象的实例变量。
实质上，对象就是将一个数结构（实例变量）和一组程序（方法）捆绑到一个独立的编程单元。
一般通过对象的方法来访问对象的状态。
1.创建对象分为两个阶段：对象分配和初始化。[[classname alloc]init]

1.1 分配对象
当分配一个对象是，iOS从应用程序的虚存区中为对象分配足够的内存。
只在计算需要的分配多少内存时，iOS会考虑对象的实例变量，包括其类型和顺序，这些信息有对象的类来定义。
为了进行对象分配，需要向对象的类发送alloc或allocWithZone：消息。在消息否返回值中可以得到一个为初始化的类实例。
alloc方法使用应用程序默认的虚存区。除了分配内存之外，iOS还进行了其他重要的工作：
将对象的保持数设置为1.
使初始化对象的isa实例变量指向对象的类。对象的类是一个根据类定义编译得到的运行时对象。
将其他所有的实例变量初始化为0（或者与0等价的类型，如nil，NULL）

1.2初始化对象
初始化过程就是将对象的实例变量设置为合理而有用的初始值，并分配和准备对象需要的其他全局资源。
如果一个对象没有实现自己的初始化方法，iOS就会调用其最近的祖先对象的方法。

对象初始化实现
NSObject声明了init方法作为初始化方法的原型，这是一个实例方法，返回一个类型为id的对象。
例如，定义Account类，正确初始化一个Account对象必须要一个唯一的账号，而这个账号必须提供初始化方法，这样初始化方法可能需要接收一个或多个参数。唯一的要求是初始化方法必须用init字母开头
子类可以不采用带参数的初始化方法，而是实现一个简单的init方法，并在初始化后使用set存取方法，并将对象设置为有用的初始状态
-(id)initWithFrame:(NSRect)frameRect;
括号中是对应的类，初始化方法都是以init字母开头的，返回类型为id的动态类型对象的实例方法。
为了减少工作没法，很多对象有init开头的方法，以NSString为例：
NSString：*emotyString = [[NSString alloc]init];
Xcode提供的自动匹配功能非常实用，输入init后按esc键会显示所有的可以匹配的函数。
所有使用alloc、copy、new方法创建的对象，使用完成之后都需要释放。
[str release]；
str在这里是自动释放的，当自动释放池呗销毁时，该字符串对象也被清理。
一般在main（）函数中首先创建自动释放池，为将要自动释放的对象在等待自动释放池被销毁时提供容身之地：
NSAutoreleasePool *pool;
pool = [[NSAutoreleasePool alloc]init];
在程序结束时释放pool，并向池中的所有对象发送release消息：
[pool release];

初始化方法
虽然init方法的方法签名要求它们返回一个对象，但是返回的并不一定是最近分配的对象，即不一定是init消息的接受对象。
有些时候，init不能执行其他对象请求的初始化，如 initFromFile：方法 希望根据一个文件的内容来初始化对象，文件的路径作为参数传入。如果在指定的地方不存在该文件，该对象就不能被初始化。
如果传给initWithArray：方法的是一个NSDictionary对象，而不是NSArray对象，也会发生类似的问题。
当一个init方法不能对对象进行初始化时，应当释放刚刚分配的对象，并返回nil。
从初始化方法返回nil表示不能创建被请求的对象，在创建对象时，通常应该在处理之前检查返回值是否nil；
由于init方法可能返回nil或不同与显示分配的对象，因此使用alloc或allocWithZone：方法而不是初始化方法返回的对象是有危险的。
一旦对象被初始化，就不应该再对其进行初始化。如果试图重复初始化，实例化对象的框架类通常会产生一个异常。
