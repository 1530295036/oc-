有两种方式定义的协议
非正式协议：为特定目标设定的
正式协议：由编译器保证的
协议负责声明可以被任意类所实现的方法，至少应用于以下3种情况：
声明对象需要实现的方法
为一个对象声明接口来隐藏它的类
抽出没有继承关系的类之间的相似之处

预定义声明接口
类和接口声明了由某一个类联系起来的一些方法，即类在大部分情况下需要实现的方法。
此外，正式和非正式的协议所声明的方法独立于任何一个特定的类，但是这个方法是任何一个类，或者很多类都有可能实现的。
协议只不过是一个方法声明的列表，并不附属于某一个类的定义。
协议使方法的声明可以不受继承关系的影响，所以协议可以用在一些类和分类所不能及的地方。协议列出可能在某些地方被实现的方法，但是并不关心具体是哪个类实现的，它所关心的只是是否有一个类遵守了这个协议，即是否实现了这个协议所声明的方法。
这样，对象不仅可以按照继承关系来分类，还可以根据它们所遵守的协议来分类。
不在同一继承关系中的类也可能属于同一类型，因为它们可能遵守相同的协议。
协议在面向对象设计中可以发挥很大的作用，特别是当一个工程要把许多实现的方法区分开或者这个过程中包含了一些其他工程中开发的对象时。
Cocoa大量使用协议来实现通过oc消息就行进程间的通信。

预定义方法
如果知道一个对象所属的类，就可以查看它的接口声明（还包含继承到的接口声明）来知道它所响应的消息。这些声明中说明了对象所能接受的消息，而协议则提供了一个途径说明了它所发送的消息。
对象通过发送和接受消息进行通信。例如，一个对象可能会将一个操作委托给另一个对象去执行，或者仅是向另一个对象请求一些消息。在某些情况下，一个对象可能希望把它的动作通知给其他对象，以使它们进行必要的处理
如果为同一个工程开发发送类和接受类（或者已经提供类接受类和其接口文件），这种通信是容易协调的。
只需要发送类引用接受类的接口文件，这个接口文件声明了发送类发送的消息中所使用的方法选择器。
然而，如果开发一个对象负责发送消息而接受对象还为定义（也就是说是留给以后实现），当然也就不可能得到接收者的接口文件类。这样就需要有一个途径来声明要在消息中使用的办法，但是并不实现它。
协议 通知编译器 类 所使用的方法，同时还通知其他 实现 这些方法的类，协议需要定义这些 方法 来 同所定义的 类 协同工作。

协议可以声明用于匿名对象（不知道类型的对象）声明方法。
匿名对象可以获得代表一种服务或是特定的一组功能，特别是当只需要一种类型的对象时（对象在定义一个应用的结构中占有重要的地位，并且必须初始化才能使用的对象不适合作为匿名对象）
对象对于其他开发者来说不是匿名的，但是当它们被提供给其他用户使用时就不同了。
某人提供了一个框架或一组对象供其他人使用，框架中可能包含一些对象，这些对象并没有标明类型，即是哪个类或哪个接口。
由于缺少类名和接口名，用户即不能创建某一个类的实例。换言之，这些类的提供者必须提供一个已经初始化并分配好的实例。
典型的方法就是有另一个类提供一个方法来返回一个可用的实例对象。
id formatter = [receiver formattingService];
这个方法返回的是一个没有指明类型的对象，至少是一个提供者不想指明的。
为了让这个对象可以使用，提供者至少要指明它可以响应的消息又那些。
这些消息就由与它相关的对象使用一个协议通过声明一个方法列表来标明。
可以发送一个消息到一个远程对象（在其他应用中的对象）。
每个应用都有自己的结构、类和内部逻辑，但是调用者并不需要了解其他应用是怎么工作的或其组件之间是如何通信的。
作为一个外部调用者，只需要知道能发送什么样的消息（协议）和发送给谁（接收者）。
如果一个应用将它的一个对象声明作为远程消息的潜在接收者，那么同时必须声明一个协议来声明这个对象用于响应哪些消息的方法。
作为发送者的应用不需要知道这个对象的类型或在自己的设计中使用这个类，需要的仅仅是协议
协议使匿名对象称为可能。没有协议，就没有办法声明一个对象的接口而不指明它的类。
注意：匿名对象的提供者虽然没有标明其类型，但是对象在运行时会暴露它的类型。类消息会返回匿名对象的类。然而，挖掘这些额外的信息是没什么意义的，协议中的信息已经足够了
